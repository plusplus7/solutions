---
layout: post
title: 【Weekly Report】2020.04.19 ~ 2020.04.25
date: 2020-04-19 07:07
tags:
    - Weekly
---

# 全年一共52个日历周，本周是第18周

Your 2020 usage:34.6%

```
[##################                                                  ]
```

# 防护升级！兼职安全工程师如何假装很熟练地给网站做安全检查

从14年起，我便开始维护我的个人主页plusplus7.com。因为本来就是业余时间维护，所以没有弄得太复杂。总体来说，就是一个Python + Redis + MySQL的小网站，还不支持HTTPS。

被PL爷吐槽“我去上个厕所的功夫就能给你黑掉”，于是我便做了少些安全加固，最重要的一点就是加上了HTTPS。

当然，用了HTTPS也并不代表网站就是安全的。特别是对于用户来说，HTTPS可以保证通信线路安全，但是无法防止服务端的主观恶意。

HTTPS的配置也并不简单。那么有没有什么工具可以简单快速地对网站做安全检查呢？

### Qualys SSL Labs

Qualys公司提供的SSL Labs是一套针对SSL扫描分析的文档和工具。其中便提供了对服务器进行扫描分析的[SSL Server Test](https://www.ssllabs.com/ssltest/index.html)。

![QualysMain](https://raw.githubusercontent.com/plusplus7/solutions/master/weekly/2020/miscs/week15/QualysSslMain.png)


SSL Server Test的扫描大致包含四个步骤：

1. 查看证书是否合法
2. 扫描服务器的SSL配置，比如协议，密钥交换算法，加密算法等
3. 根据扫描结果得出分数，从0到100
4. 最后再根据分数和一套特殊规则，来给出最后的评级，从A到F。

有的规则可能会导致评级下降，而有的规则会提升评级。当然，还有一些特殊的情况，也会给出M级：证书名不匹配和T级：证书不被信任。

大概过1分钟左右，检查完成。

最终，我的网站拿到了B级的评价！

![Qualys_plusplus7com](https://raw.githubusercontent.com/plusplus7/solutions/master/weekly/2020/miscs/week15/Qualys_plusplus7com.png)

扫描报告分为几个部分，每一部分包含若干子项目。存在安全风险的项目会被标记为橙色。

### Part 1 证书

![Qualys_plusplus7com](https://raw.githubusercontent.com/plusplus7/solutions/master/weekly/2020/miscs/week15/Qualys_Part1Certificate.png)

第一部分是证书。

Subject, Common name, Alternative names, Serial Number...这些都是普通的证书应该有的属性。

#### Key

这一栏的信息表明，生成这份证书的Key是2048位的RSA密钥，其中E=65537。

#### Weak Key(Debian)

Linux系统的Debian发行版在2006发布的OpenSSL包中包含一个bug。这个bug使得Debian以及其衍生系统会生成较弱的密钥。这个bug直到2008年才被修复。

这项检测便是针对这个bug来检查证书中是否使用了此类较弱的密钥。

#### Issuer

我的这份证书是由Let's Encryt颁发的，所以Issuer这一栏是Let's Encryt证书机构的信息。

#### Signature algorithm

这里的SHA256WithRSA，是指浏览器需通过SHA256算法计算证书摘要+RSA私钥签名来验证证书链。

#### Extended Validation

这里的Extended Validation，缩写为EV，是指SSL证书的验证级别。目前的级别分为DV，OV，EV三种。

* DV, Domain validated. 获得该类型证书只需要通过域名所有者邮箱验证，或者在域名下，添加一个外部可访问的路径，内容为CA提供的验证文件。

* OV, Organization validated. 获得该类型证书，需要在DV证书的基础上，并且需要请求者属于某一个组织，如，银行，企业，政府单位。不同CA有不同的方式去验证该组织的合法性。

* EV, Extended validation.  获得该类型证书，需要在OV证书的基础上，验证方式更加严格，包括但不限于人工审核。

我在Let's Encryt上申请的证书属于最容易获得的DV证书，所以这里的扫描结果是No。

#### Certificate Transparency

Certificate Transparency，缩写为CT，是一项用于监控审计证书签发的通用标准。所有的CA签发证书时，必须写一条记录到公开透明的CT日志服务器中。任何人以及浏览器都可以去访问日志服务器来验证该证书是否在CT日志服务器中存在。

当证书被成功提交到CT服务器，CT服务器会返回一个Signed certificate timestamp，缩写为SCT。浏览器便可以根据SCT去日志服务器检查证书是否存在。

当服务器不提供SCT，这里的扫描结果会显示为No。如果是Yes的话，这里的结果也有可能是以下有三种。

* Yes(certificate)
* Yes(TLS extension)
* Yes(stapled OCSP response)

我的情况属于第一种，SCT附带在证书中。第二种情况，是说明SCT是服务器在TLS握手中附带在Server Hello信息中。最后一种情况是说SCT是附带在OCSP Stapling信息中。见下面的OCSP部分。

参考[How Is Certificate Check](https://discussions.qualys.com/thread/16972-how-is-certificate-checked-for-certificate-transparency)

#### OCSP Must Staple

Online Certificate Status Protocol，缩写为OCSP，是一个用于获取证书吊销状态的通用协议。浏览器可以使用OCSP来验证HTTPS证书是否被吊销。

OCSP相较于更原始的CRL，更精简更易实现。OCSP的问题也显而易见。

对于一个HTTPS证书，将会有若干的浏览器去验证其合法性，这势必会让OCSP服务器需要同时响应大量请求。所以便有了OCSP Stapling技术。

OCSP Stapling让服务器主动去OCSP服务器获取一个带签名的OCSP证书状态，并在TLS握手时将其发送给浏览器。浏览器拿到之后便可以在本地直接校验签名和证书状态是否合法，无需再去OCSP服务器请求验证证书。这项技术同时提升了安全和性能。

OCSP Must-Staple是一个证书中的扩展属性，用于告诉浏览器必须通过OCSP检查证书状态，否则就中断访问。

正确配置OCSP Must-Staple并不简单，其需要1. CA颁发证书时添加该扩展属性；2. 服务端提供OCSP Stapling；3. 浏览器正确实现OCSP Must-Staple，否则这个配置将毫无意义。

#### Revocation information

证书吊销信息。这里显示扫描器通过Let's Encryt提供的OCSP检查到了我的证书状态。这里也有可能会显示CRL。

#### Revocation status

证书状态。这里显示我的证书并没有被吊销。

#### DNS CAA

DNS Certification Authority Authorization，简写为DNS CAA，可以让域名持有者通过在DNS服务器中添加一条CAA记录来指定该域名的证书只允许由某特定的CA机构颁发。

我的域名没有添加这类记录，所以扫描结果为No。

#### Trusted

证书是否被信任。

总的来说，我的域名和证书虽然还有一些可以提升的空间，但是已经符合可以安全访问的标准，所以被常见的设备和浏览器信任。

这里列出了Mozilla，Apple，Android，Java和Windows，均为绿色，表示证书被信任。

#### Additional and Others

之后的部分还包括证书链，以及CA的Root证书信息。


### TLS/SSL配置

![Qualys_plusplus7com](https://raw.githubusercontent.com/plusplus7/solutions/master/weekly/2020/miscs/week15/Qualys_Part2Configuration.jpg)

#### Protocols 协议

这里列出了常见的TLS握手协议。TLS 1.2之前的所有协议均被视为存在安全漏洞，所以被标记为黄色(Weak)。

我的服务器支持TLS 1.0/1.1/1.2，其中TLS 1.0和TLS 1.1协议已经有将近20年的历史，并且有已知攻击对旧版本的TLS有效，如：

* POODLE
* BEAST
* ...

![Qualys_plusplus7com](https://raw.githubusercontent.com/plusplus7/solutions/master/weekly/2020/miscs/week15/Qualys_TLSVulnerability.jpg)

Apple, Google, Microsoft和Mozilla在很早之前已经宣布将在2020年结束对TLS旧版本的支持。

![Qualys_plusplus7com](https://raw.githubusercontent.com/plusplus7/solutions/master/weekly/2020/miscs/week15/Qualys_AGMMTLS.png)


参考[常见TLS攻击样例](https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/)


#### DROWN 

Decrypting RSA with Obsolete and Weakened eNcryption，缩写为DROWN，是一种利用安全漏洞的跨协议攻击。

DROWN针对“出口级”加密套件，使用基于Adaptive chosen-ciphertext attack的暴力破解方式来破解SSLv2链接的会话密钥。由于在现实场景中，部署TLS的服务器不止一台，并且很有可能多个服务器使用同一份证书/密钥。一旦某台支持SSLv2服务器的会话密钥被泄露，这个攻击将可以扩散到其他服务器，即使其他服务器不支持SSLv2。

针对DROWN的扫描比较特殊。由于这种攻击的特性，仅扫描单台服务器是否支持SSLv2是不够的。于是SSL Labs会去DROWN作者提供的数据库中查看证书公钥和Hostname是否存在。

#### Secure Renegotiation

这项扫描是针对TLS握手的再协商。[RFC5246][SR.1]中规定，TLS链接建立之后允许客户端和服务端任何一方发起再协商。比如，客户端访问服务器资源，随后，服务器需要对客户端进行Mutual Authentication双向证书认证。

然而，再协商的握手所交换的信息和前一轮并没有安全绑定关系，服务器无法判断这两轮握手是否都是来自同一客户端。这给了黑客实施中间人攻击的可能性。

黑客切断客户端到服务器的链接，先给服务器建立一次TLS握手，随后再恢复客户端到服务器的链接，让客户端和服务端通信。此时，服务器会认为黑客和客户是同一方。

为了解决这个问题，在[RFC 5746][SR.2]中定义了Secure Renegotiation标准。这项扫描便是检查服务器是否支持Secure Renegotiation。

重协商类型一共有4种：

* Client-initiated secure renegotiation
* Client-initiated insecure renegotiation
* Server-initiated secure renegotiation
* Server-initiated insecure renegotiation

SSL Labs这里还扫描了Secure Client-Initiated Renegotiation 和 Insecure Client-Initiated Renegotiation。

#### BEAST attack

TLS 1.0及更早版本有一个重大缺陷：Initialization Vector初始向量可以被中间人攻击的攻击者预测到。

同一把密钥使用同一种对称加密算法加密同一块内容时，得出的结果总是一样的。而IV则主要被用于防止每次加密产生同一种结果，否则攻击者将可以猜到密文解密后的内容。

对于攻击者来说，他可以先预测IV，然后收集加密数据，再猜测密文解密的内容。虽然攻击者不能直接解密内容，但是他可以判断他的猜测是否正确。

有了足够的观察数据之后，便足以形成数据泄露。

#### POODLE attack (SSLv3)

POODLE attack属于padding oracle attack，主要用于攻击SSLv3的CBC模式的加密算法。和BEAST类似，攻击者使用POODLE也可以用于解密SSL链接中的加密信息，比如cookie。

由于块加密的特性，在加密消息末尾字符数量不足以凑齐整块的，需要填充部分空白字符。在SSLv3中并没有指定填充字符的内容，所以接受方并不需要检查填充字符，只要填充字符的数量正确且能够正确解密验证消息完整性即可。

攻击者通常会将攻击脚本放在网页JavaScript脚本中，并由攻击者主动发起HTTPS链接，因此攻击者可以控制填充字符的长度。由于CBC模式的特点，攻击者可以将cookie所在的块复制到密文的尾部，替换掉填充字符的块，这样便会有1/256的几率，服务器会认为该请求是合法的。然后攻击者通过使用填充块来异或倒数第二个块，便可以拿到cookie块的最后一个字符的内容。

如果请求被服务器拒绝，那么就重新发起请求。因为加密会使用随机的IV，所以理论上来说每次倒数第二块的加密结果都不同。

算出最后一个字符后，就将URL长度增加一个字符，然后继续算倒数第二个字符，直到将cookie中所有字符全部拿到。

这个攻击的存在，使得人们确定SSLv3不再安全。

#### POODLE attack (TLS)

为了防御POODLE攻击，TLS对于填充字符有严格的限制。但是，有报道称部分TLS的实现并没有去检查填充字符的结构，导致使用TLS协议也有可能被POODLE攻击。

#### Zombie POODLE

Zombie POODLE是POODLE攻击的进化版本。

人们为了防御POODLE攻击，在TLS协议中添加了检查填充字符内容的要求。但是有研究者发现，部分网站对于填充字符检查的实现方式依然存在漏洞。

1. 解密TLS消息
2. 提取最后一个字符的内容作为填充字符的长度
3. 根据填充字符长度来提取消息校验码
4. 计算消息校验码是否匹配
5. 如果不匹配，则重置TCP链接
6. 检查填充字符结构是否正确
7. 如果不正确，则发出TLS报警，然后重置TCP链接

有问题的部分，就在于攻击者可以根据服务器是否发出TLS报警来判断，cookie块异或密文的倒数第二块后是否正好为填充字符的长度。所以其实这里就算检查了填充字符的结构，依然没有防止住POODLE攻击

#### GOLDENDOODLE

GOLDENDOODLE是POODLE的变种，主要攻击对象是受到CVE-2015-4558影响的Cisco设备。

受CVE-2015-4558影响的Cisco设备，不会检查消息校验码。这给了攻击者机会去主动填充校验码来推测cookie块中的值。由于cookie的值大多数可见字符，GOLDENDOODLE的效率比DOODLE快很多。

#### OpenSSL 0-Length

这项扫描是针对[CVE-2019-1559][O0L.1]。

OpenSSL 1.0.2版本的用户在收到带有合法消息校验码和填充块的0字符消息时，会经过大概数秒钟之后才关闭连接，而不是像其他情况一样，立即关闭连接。这是一个错误的实现，而且很容易被黑客观察到。



[SR.1]: https://tools.ietf.org/html/rfc5246
[SR.2]: https://tools.ietf.org/html/rfc5746
[SR.3]: https://www.mcafee.com/blogs/enterprise/tips-securing-ssl-renegotiation/
[BA.1]: https://blog.qualys.com/ssllabs/2011/10/17/mitigating-the-beast-attack-on-tls
[PD.1]: https://www.openssl.org/~bodo/ssl-poodle.pdf
[PD.2]: https://www.imperialviolet.org/2014/10/14/poodle.html
[PD.3]: https://www.imperialviolet.org/2014/12/08/poodleagain.html
[ZPD.1]: https://www.tripwire.com/state-of-security/vert/zombie-poodle/
[GDD.1]: https://www.youtube.com/watch?v=R5z0mhzxKGc
[O0L.1]: https://www.openssl.org/news/secadv/20190226.txt